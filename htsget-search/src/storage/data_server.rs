//! The following module provides an implementation of [UrlFormatter] for https, and the server
//! code which responds to formatted urls.
//!
//! This is the code that replies to the url tickets generated by [HtsGet], in the case of [LocalStorage].
//!

use std::fs::File;
use std::io::BufReader;
use std::net::{AddrParseError, SocketAddr};
use std::path::{Path, PathBuf};
use std::pin::Pin;
use std::sync::Arc;

use axum::http;
use axum::Router;
use axum_extra::routing::SpaRouter;
use futures_util::future::poll_fn;
use http::uri::Scheme;
use hyper::server::accept::Accept;
use hyper::server::conn::{AddrIncoming, Http};
use rustls_pemfile::{certs, pkcs8_private_keys};
use tokio::net::TcpListener;
use tokio_rustls::rustls::{Certificate, PrivateKey, ServerConfig};
use tokio_rustls::TlsAcceptor;
use tower::MakeService;
use tower_http::trace::TraceLayer;
use tracing::instrument;
use tracing::{info, trace};

use crate::storage::StorageError::{IoError, DataServerError};
use crate::storage::UrlFormatter;

use super::{Result, StorageError};

/// A certificate and key pair used for tls.
/// This is the path to the PEM formatted X.509 certificate and private key.
#[derive(Debug, Clone)]
pub struct CertificateKeyPair {
  cert: PathBuf,
  key: PathBuf,
}

/// Ticket server url formatter.
#[derive(Debug, Clone)]
pub struct HttpTicketFormatter {
  addr: SocketAddr,
  cert_key_pair: Option<CertificateKeyPair>,
  scheme: Scheme,
}

impl HttpTicketFormatter {
  const SERVE_ASSETS_AT: &'static str = "/data";

  pub fn new(addr: SocketAddr) -> Self {
    Self {
      addr,
      cert_key_pair: None,
      scheme: Scheme::HTTP,
    }
  }

  pub fn new_with_tls<P: AsRef<Path>>(addr: SocketAddr, cert: P, key: P) -> Self {
    Self {
      addr,
      cert_key_pair: Some(CertificateKeyPair {
        cert: PathBuf::from(cert.as_ref()),
        key: PathBuf::from(key.as_ref()),
      }),
      scheme: Scheme::HTTPS,
    }
  }

  /// Returns a data server with tls if both cert and key are not None, without tls if cert and key
  /// are both None, and otherwise an error.
  pub fn try_from<P: AsRef<Path>>(
    addr: SocketAddr,
    cert: Option<P>,
    key: Option<P>,
  ) -> Result<Self> {
    match (cert, key) {
      (Some(cert), Some(key)) => Ok(Self::new_with_tls(addr, cert, key)),
      (Some(_), None) | (None, Some(_)) => Err(DataServerError(
        "both the cert and key must be provided for the data server".to_string(),
      )),
      (None, None) => Ok(Self::new(addr)),
    }
  }

  /// Get the scheme this formatter is using - either HTTP or HTTPS.
  pub fn get_scheme(&self) -> &Scheme {
    &self.scheme
  }

  /// Eagerly bind the address by returning an AxumStorageServer. This function also updates the
  /// address to the actual bound address, and replaces the cert_key_pair with None.
  pub async fn bind_data_server(&mut self) -> Result<DataServer> {
    let server =
      DataServer::bind_addr(self.addr, Self::SERVE_ASSETS_AT, self.cert_key_pair.take()).await?;
    self.addr = server.local_addr();
    Ok(server)
  }

  /// Get the [SocketAddr] of this formatter.
  pub fn get_addr(&self) -> SocketAddr {
    self.addr
  }
}

impl From<AddrParseError> for StorageError {
  fn from(err: AddrParseError) -> Self {
    StorageError::InvalidAddress(err)
  }
}

/// The local storage static http server.
#[derive(Debug)]
pub struct DataServer {
  listener: AddrIncoming,
  serve_assets_at: String,
  cert_key_pair: Option<CertificateKeyPair>,
}

impl DataServer {
  /// Eagerly bind the the address for use with the server, returning any errors.
  #[instrument(skip(serve_assets_at, cert_key_pair))]
  pub async fn bind_addr(
    addr: SocketAddr,
    serve_assets_at: impl Into<String>,
    cert_key_pair: Option<CertificateKeyPair>,
  ) -> Result<DataServer> {
    let listener = TcpListener::bind(addr)
      .await
      .map_err(|err| IoError("binding data server addr".to_string(), err))?;
    let listener = AddrIncoming::from_listener(listener)?;

    info!(address = ?listener.local_addr(), "Htsget data server address bound to");
    Ok(Self {
      listener,
      serve_assets_at: serve_assets_at.into(),
      cert_key_pair,
    })
  }

  /// Run the actual server, using the provided path, key and certificate.
  #[instrument(level = "trace", skip_all)]
  pub async fn serve<P: AsRef<Path>>(mut self, path: P) -> Result<()> {
    let mut app = Router::new()
      .layer(TraceLayer::new_for_http())
      .merge(SpaRouter::new(&self.serve_assets_at, path))
      .into_make_service_with_connect_info::<SocketAddr>();

    match self.cert_key_pair {
      None => axum::Server::builder(self.listener)
        .serve(app)
        .await
        .map_err(|err| DataServerError(err.to_string())),
      Some(CertificateKeyPair { cert, key }) => {
        let rustls_config = Self::rustls_server_config(key, cert)?;
        let acceptor = TlsAcceptor::from(rustls_config);

        loop {
          let stream = poll_fn(|cx| Pin::new(&mut self.listener).poll_accept(cx))
            .await
            .ok_or_else(|| DataServerError("poll accept failed".to_string()))?
            .map_err(|err| DataServerError(err.to_string()))?;
          let acceptor = acceptor.clone();

          let app = app
            .make_service(&stream)
            .await
            .map_err(|err| DataServerError(err.to_string()))?;

          trace!(stream = ?stream, "accepting stream");
          tokio::spawn(async move {
            if let Ok(stream) = acceptor.accept(stream).await {
              let _ = Http::new().serve_connection(stream, app).await;
            }
          });
        }
      }
    }
  }

  /// Get the local address the server has bound to.
  pub fn local_addr(&self) -> SocketAddr {
    self.listener.local_addr()
  }

  fn rustls_server_config<P: AsRef<Path>>(key: P, cert: P) -> Result<Arc<ServerConfig>> {
    let mut key_reader = BufReader::new(
      File::open(key).map_err(|err| IoError("failed to open key file".to_string(), err))?,
    );
    let mut cert_reader = BufReader::new(
      File::open(cert).map_err(|err| IoError("failed to open cert file".to_string(), err))?,
    );

    let key = PrivateKey(
      pkcs8_private_keys(&mut key_reader)
        .map_err(|err| IoError("failed to read private keys".to_string(), err))?
        .remove(0),
    );
    let certs = certs(&mut cert_reader)
      .map_err(|err| IoError("failed to read certificate".to_string(), err))?
      .into_iter()
      .map(Certificate)
      .collect();

    let mut config = ServerConfig::builder()
      .with_safe_defaults()
      .with_no_client_auth()
      .with_single_cert(certs, key)
      .map_err(|err| DataServerError(err.to_string()))?;

    config.alpn_protocols = vec![b"h2".to_vec(), b"http/1.1".to_vec()];

    Ok(Arc::new(config))
  }
}

impl From<hyper::Error> for StorageError {
  fn from(error: hyper::Error) -> Self {
    DataServerError(error.to_string())
  }
}

impl UrlFormatter for HttpTicketFormatter {
  fn format_url<K: AsRef<str>>(&self, key: K) -> Result<String> {
    http::uri::Builder::new()
      .scheme(self.get_scheme().clone())
      .authority(self.addr.to_string())
      .path_and_query(format!("{}/{}", Self::SERVE_ASSETS_AT, key.as_ref()))
      .build()
      .map_err(|err| StorageError::InvalidUri(err.to_string()))
      .map(|value| value.to_string())
  }
}

#[cfg(test)]
mod tests {
  use std::str::FromStr;

  use reqwest::ClientBuilder;

  use htsget_test_utils::util::generate_test_certificates;

  use crate::storage::local::tests::create_local_test_files;

  use super::*;

  #[tokio::test]
  async fn test_http_server() {
    let (_, base_path) = create_local_test_files().await;

    test_server_request("http", None, base_path.path().to_path_buf()).await;
  }

  #[tokio::test]
  async fn test_tls_server() {
    let (_, base_path) = create_local_test_files().await;
    let (key_path, cert_path) = generate_test_certificates(base_path.path(), "key.pem", "cert.pem");

    test_server_request(
      "https",
      Some(CertificateKeyPair {
        cert: cert_path,
        key: key_path,
      }),
      base_path.path().to_path_buf(),
    )
    .await;
  }

  #[test]
  fn http_formatter_authority() {
    let formatter = HttpTicketFormatter::new("127.0.0.1:8080".parse().unwrap());
    test_formatter_authority(formatter, "http");
  }

  #[test]
  fn https_formatter_authority() {
    let formatter = HttpTicketFormatter::new_with_tls("127.0.0.1:8080".parse().unwrap(), "", "");
    test_formatter_authority(formatter, "https");
  }

  #[test]
  fn http_scheme() {
    let formatter = HttpTicketFormatter::new("127.0.0.1:8080".parse().unwrap());
    assert_eq!(formatter.get_scheme(), &Scheme::HTTP);
  }

  #[test]
  fn https_scheme() {
    let formatter = HttpTicketFormatter::new_with_tls("127.0.0.1:8080".parse().unwrap(), "", "");
    assert_eq!(formatter.get_scheme(), &Scheme::HTTPS);
  }

  #[tokio::test]
  async fn get_addr_local_addr() {
    let mut formatter = HttpTicketFormatter::new("127.0.0.1:0".parse().unwrap());
    let server = formatter.bind_data_server().await.unwrap();
    assert_eq!(formatter.get_addr(), server.local_addr());
  }

  async fn test_server_request<P>(scheme: &str, cert_key_pair: Option<CertificateKeyPair>, path: P)
  where
    P: AsRef<Path> + Send + 'static,
  {
    // Start server.
    let addr = SocketAddr::from_str(&format!("{}:{}", "127.0.0.1", "0")).unwrap();
    let server = DataServer::bind_addr(addr, "/data", cert_key_pair)
      .await
      .unwrap();
    let port = server.local_addr().port();
    tokio::spawn(async move { server.serve(path).await.unwrap() });

    // Make request.
    let client = ClientBuilder::new()
      .danger_accept_invalid_certs(true)
      .use_rustls_tls()
      .build()
      .unwrap();
    let response = client
      .get(format!("{}://{}:{}/data/key1", scheme, "localhost", port))
      .send()
      .await
      .unwrap()
      .bytes()
      .await
      .unwrap();

    assert_eq!(response.as_ref(), b"value1");
  }

  fn test_formatter_authority(formatter: HttpTicketFormatter, scheme: &str) {
    assert_eq!(
      formatter.format_url("path").unwrap(),
      format!(
        "{}://127.0.0.1:8080{}/path",
        scheme,
        HttpTicketFormatter::SERVE_ASSETS_AT
      )
    )
  }
}
